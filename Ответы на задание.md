# Kollokviym_OS3
### 1. Классические поведенческие шаблоны проектирования  

#### 1.1. Шаблон "Команда" (Command)  
Определение:  
Инкапсулирует запрос в виде объекта, позволяя параметризовать клиентов с различными запросами, организовывать их в очереди, логировать и поддерживать отмену операций.  

Проблема:  
- Жесткая связь между отправителем запроса и его обработчиком.  
- Невозможность отмены, повтора или логгирования операций.  
- Сложность реализации сложных транзакций.  

Решение:  
- Инкапсуляция запроса в объект (`Command`), который содержит метод `execute()`.  
- Разделение отправителя (`Invoker`) и получателя (`Receiver`).  

Примеры:  
1. Графический редактор: Кнопка "Отменить" (`UndoCommand`) хранит историю выполненных команд.  
2. Очередь задач: Задачи (`Runnable` в Java) передаются в `ThreadPool`.  
3. Транзакции БД: Каждая операция (`InsertCommand`, `DeleteCommand`) может быть отменена.  

Многопоточность: 
- Команды могут выполняться асинхронно (например, `ExecutorService`).  
- Требуется синхронизация, если команды изменяют общее состояние.  

#### 1.2. Шаблон "Стратегия" (Strategy) 
Определение:  
Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.  

Проблема:  
- Множество условных операторов (`if-else`/`switch`) для выбора алгоритма.  
- Жесткая зависимость кода от конкретной реализации.  

Решение:  
- Выделение алгоритмов в отдельные классы (`ConcreteStrategy`).  
- Использование общего интерфейса (`Strategy`).  

Примеры:  
1. Сортировка: Выбор между `QuickSort`, `MergeSort`, `BubbleSort`.  
2. Оплата: Разные способы (`CreditCard`, `PayPal`, `Crypto`).  
3. Навигация: Маршрутизация (`CarRoute`, `WalkingRoute`, `PublicTransportRoute`).  

Многопоточность:  
- Каждая стратегия должна быть потокобезопасной.  
- Можно применять разные стратегии в разных потоках без блокировок, если они не изменяют общие данные.  

#### 1.3. Шаблон "Шаблонный метод" (Template Method) 
Определение:  
Определяет скелет алгоритма, делегируя некоторые шаги подклассам.  

Проблема:  
- Повторяющийся код в родственных классах.  
- Жесткая привязка к структуре алгоритма.  

Решение:  
- Базовый класс определяет шаги алгоритма (`templateMethod()`).  
- Подклассы переопределяют абстрактные/виртуальные методы (`step1()`, `step2()`).  

Примеры:  
1. Игра: `Game` определяет `init() → play() → end()`, а `Chess` и `Monopoly` реализуют свои правила.  
2. Сборка ПО: `BuildPipeline` (`fetch → compile → test → deploy`), где `compile` зависит от языка.  
3. Документооборот: `DocumentProcessor` (`open → process → save`), где `process` разный для `PDF` и `DOCX`.  

Многопоточность:  
- Если шаги выполняются в разных потоках, нужна синхронизация.  
- Можно использовать `Hook`-методы для потокобезопасных операций.  

### 2. Архитектура ПО и многопоточность  

#### 2.1. Что такое архитектура ПО?  
Архитектура ПО — это высокоуровневая структура системы, включающая:  
- Основные компоненты и их взаимодействие.  
- Принципы принятия проектных решений (масштабируемость, отказоустойчивость).  
- Стили (монолит, микросервисы, событийно-ориентированная).  

Ключевые аспекты:  
- Модульность (разделение ответственности).  
- Слабая связанность (ортогональность компонентов).  
- Масштабируемость (вертикальная/горизонтальная).  

#### 2.2. Влияние многопоточности на архитектуру  
1. Сложность управления состоянием:  
   - Гонки данных, deadlocks требуют продуманной синхронизации (`synchronized`, `Atomic`, `immutable` объекты).  
2. Производительность vs. Безопасность:  
   - Чем больше блокировок, тем хуже параллелизм (альтернативы: `CAS`, `Actor Model`).  
3. Распределённые системы:  
   - Асинхронность (`Message Queues`, `Reactive Programming`).  
4. Паттерны для многопоточности:  
   - `Producer-Consumer`, `Thread Pool`, `Read-Write Lock`.  
